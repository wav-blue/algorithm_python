### 01 숫자의 합 구하기

- 기본 문제(형변환)

### 02 평균 구하기

- 기본 문제(계산)

## 구간 합

### 03 구간합 구하기 1

- 합 배열을 생성하여 시간을 절약(1차원 배열)

### 04 구간합 구하기 2

- 합 배열을 생성하여 시간을 절약(2차원 배열)

### 05 나머지 합 구하기

- 합배열 / 나머지 연산

> **아이디어 1**<br>
> 1+5를 3으로 나눈 나머지는
>
> 1을 3으로 나눈 나머지인 1,<br>
> 4를 3으로 나눈 나머지인 2
>
> 1+2를 3으로 나눈 나머지와 같아진다

> **아이디어 2**<br>
> 합배열을 구하고 3으로 나누었을 때<br>
> (end-start)= 구간의 합인데<br>
> end지점과 start 지점의 값이 같다면 그 구간의 합은 3으로 나누어 떨어진다는 뜻이 된다.

> **예시**<br/>
> 원본 [1, 2, 4, 5]<br/>
> 합배열 [1, 3, 7, 12]<br/>
> %3 적용 [1, 0, 1, 0]

- 0으로 값이 같은 i=1, 3을 살펴보면 (12-3)=9가 구간의 합이므로 3으로 나누어 떨어진다

- 1로 값이 같은 i=0, 2를 살펴보면 (7-1)=6이 구간의 합이므로 3으로 나누어 떨어진다

- 구간의 길이가 1일 때 3으로 나누어 떨어지는 경우도 더해야 한다.

## 투포인터

### 06 연속된 자연수의 합 구하기

- 투포인터
- 포인터를 옮기며 sum(now)의 값을 조정하여 일일히 계산하지 않는다.

### 07 주몽의 명령

- 투포인터
- 마찬가지로 포인터를 옮기며 값을 실시간으로 반영하는 것이 포인트

### 08 좋은 수

- 투 포인터
- '투포인터'를 이동하며 찾고자 하는 값을 찾는 문제 + '찾는 값' 이동

## 슬라이딩 윈도우

### 09 DNA 비밀번호

- 알고리즘: 슬라이딩 윈도우
- 방법 1: 현재 문자의 개수와 필요한 문자의 개수를 비교하여 그때마다 true, false 여부를 체크함
- 변경한 방법 2: 변경할 때 add한 문자와 remove한 문자의 증감량을 고려해서 is_valid(ACGT중 조건을 만족하는 문자 개수)를 조정함
  - => 시간복잡도 절약

### 10 최소값 찾기

- 슬라우딩 윈도우, 덱

- 순서대로 추가하고 제거해나갈 때 '뒤에 들어온 값은 앞에서 들어온 값보다 빨리 삭제되지 않는다'
- ex. 이런 명제로 5다음 3이 들어온다면 최소값이 5가 될 일은 없어지므로 5를 미리 제거해도 괜찮다.
- => 들어온 값: 현재 값보다 큰 값은 전부 제거하여 관리

- 인덱스를 벗어나는 값은 하나씩만 나온다.
- 최소값만을 검사하면 인덱스를 벗어난 값을 답으로 삼는 일은 없다.
- - => 최소값의 인덱스를 검사하여 인덱스를 벗어나지 않도록 관리
